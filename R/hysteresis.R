#' @title A function to automatically generate hysteresis plots for all
#' structural parameter estimates.
#'
#' @param GERGM_Object A GERGM object returned by the gergm() estimation
#' function.
#' @param networks_to_simulate Number of simulations per unique parameter value
#' used in the hysteresis plots. Default is 1000.
#' @param burnin Number of samples from the MCMC simulation procedure that
#' will be discarded before drawing the samples used for hysteresis plots.
#' Default is 500.
#' @param range The magnitude of the interval over which theta parameter
#' values will be varried for the hysteresis plots. The actual range will be
#' vary from a minimum of theta_value - range * abs(theta_value) to a maximum of
#' theta_value + range * abs(theta_value) so the actual parameter ranges will be
#' scaled to the magnitude of the parameter estimates. Defaults to 2.
#' @param steps The number of theta values to simulate above and below the
#' estimated theta value within the given range. The total number of simulations
#' is then = 2 * steps + 1. Defaults to 20.
#' @param simulation_method Simulation method for MCMC estimation. Default is
#' "Gibbs" but can also be set to "Metropolis".
#' @param proposal_variance The variance specified for the Metropolis Hastings
#' simulation method. This parameter is inversely proportional to the average
#' acceptance rate of the M-H sampler and should be adjusted so that the average
#' acceptance rate is approximately 0.25. Default is 0.1.
#' @param seed Seed used for reproducibility. Default is 123.
#' @param thin The proportion of samples that are kept from each simulation. For
#' example, thin = 1/200 will keep every 200th network in the overall simulated
#' sample. Default is 1.
#' @param output_directory The directory where you would like output generated
#' by this function to be saved
#' @param output_name The common name stem you would like to assign to all
#' plots generated by this function
#' @param parallel Logical indicating whether parallelization should be used to
#' speed up simulation process. Will only work for unix based systems (OS X and
#' linux, etc.). Defaults to FALSE.
#' @param cores The number of cores to be used if parallel = TRUE. Defualts to 1.
#' @return A list object containing network densities for simulated networks.
#' @examples
#' \dontrun{
#' set.seed(12345)
#' net <- matrix(rnorm(100,0,20),10,10)
#' colnames(net) <- rownames(net) <- letters[1:10]
#' formula <- net ~  mutual + ttriads
#'
#' test <- gergm(formula,
#'               normalization_type = "division",
#'               network_is_directed = TRUE,
#'               use_MPLE_only = FALSE,
#'               estimation_method = "Metropolis",
#'               number_of_networks_to_simulate = 40000,
#'               thin = 1/10,
#'               proposal_variance = 0.5,
#'               downweight_statistics_together = TRUE,
#'               MCMC_burnin = 10000,
#'               seed = 456,
#'               convergence_tolerance = 0.01,
#'               MPLE_gain_factor = 0,
#'               force_x_theta_updates = 4)
#'
#' hysteresis_results <- hysteresis(
#'     test,
#'     networks_to_simulate = 1000,
#'     burnin = 500,
#'     range = 2,
#'     steps = 20,
#'     simulation_method = "Metropolis",
#'     proposal_variance = 0.1)
#' }
#' @export
hysteresis <- function(GERGM_Object,
                       networks_to_simulate = 1000,
                       burnin = 500,
                       range = 2,
                       steps = 20,
                       simulation_method = c("Gibbs", "Metropolis"),
                       proposal_variance = 0.1,
                       seed = 12345,
                       thin = 1,
                       output_directory = NULL,
                       output_name = NULL,
                       parallel = FALSE,
                       cores = 1){

  # preliminaries
  possible_structural_terms <- c("out2stars",
                                 "in2stars",
                                 "ctriads",
                                 "mutual",
                                 "ttriads",
                                 "edges")
  currentwd <- getwd()
  simulation_method <- simulation_method[1]

  # figure out how many statistics we need to simulate values for
  num_network_terms <- length(GERGM_Object@theta.par)
  Hysteresis_Results <- vector(mode = "list", length = num_network_terms)

  for(i in 1:num_network_terms){
    # figure out the range of values for each parameter
    current_theta <- GERGM_Object@theta.par[i]
    min_val <- current_theta - range * abs(current_theta)
    max_val <- current_theta + range * abs(current_theta)
    hysteresis_values <- seq(min_val, max_val, length.out = 2 * steps + 1)
    network_densities <- matrix(0,
                                nrow = ceiling(networks_to_simulate/thin),
                                ncol = length(hysteresis_values))
    # tell the user what is going on
    which_term <- which(GERGM_Object@stats_to_use > 0)[i]
    cat("Currently simulating networks while varying the",
        possible_structural_terms[which_term],"parameter from:",min_val,"to",
        max_val,"for a total of",length(hysteresis_values),"simulations...\n")

    if(parallel){
      stop("Currently not implemented...")

    }else{
      # loop over values for theta
      for(j in 1:length(hysteresis_values)){

        # set the current value
        GERGM_Object@theta.par[i] <- hysteresis_values[j]
        print(GERGM_Object@theta.par)
        # simulate networks
        GERGM_Object <- Simulate_GERGM(
          GERGM_Object,
          nsim = networks_to_simulate,
          method = simulation_method,
          MCMC.burnin = burnin,
          thin = thin,
          shape.parameter = proposal_variance,
          together = GERGM_Object@downweight_statistics_together,
          seed1 = seed,
          possible.stats = possible_structural_terms)

        # save the densities
        nr <- nrow(GERGM_Object@network)
        normalizer <- nr * (nr - 1)
        network_densities[,j] <- GERGM_Object@MCMC_output$Statistics$edges/normalizer
      }

      # reset teh theta value
      GERGM_Object@theta.par[i] <- current_theta
      mean_densities <- apply(network_densities,2,mean)
      Hysteresis_Results[[i]] <- list(network_densities = network_densities,
                                      mean_densities = mean_densities,
                                      theta_values = hysteresis_values)
    }
  }
  # clean up a return everything
  setwd(currentwd)
  return(Hysteresis_Results)
}
