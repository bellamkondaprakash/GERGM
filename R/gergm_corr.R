## A function to estimate GERGMs for correlation matrices
#'
#'
#' @param formula A formula object that specifies the relationship between statistics and the observed network. Currently, the following statistics can be specified: c("out2star", "in2star", 	"ctriads", "recip", "ttriads", "edgeweight").
#' @param use_MPLE_only Logical specifying whether or not only the maximum pseudo likelihood estimates should be obtained. In this case, no simulations will be performed. Default is FALSE.
#' @param maximum_number_of_theta_updates Maximum number of iterations within the MCMC inner loop which estimates the ERGM parameters. Default is 100.
#' @param number_of_networks_to_simulate Number of simulations generated for estimation via MCMC. Default is 500.
#' @param thin The proportion of samples that are kept from each simulation. For example, thin = 1/200 will keep every 200th network in the overall simulated sample. Default is 1.
#' @param proposal_variance The variance specified for the Metropolis Hastings simulation method. This parameter is inversely proportional to the average acceptance rate of the M-H sampler and should be adjusted so that the average acceptance rate is approximately 0.25. 		Default is 0.1.
#' @param downweight_statistics_together Logical specifying whether or not the weights should be applied inside or outside the sum. Default is TRUE and user should not select FALSE under normal circumstances.
#' @param MCMC_burnin Number of samples from the MCMC simulation procedure that will be discarded before drawing the samples used for estimation. Default is 100.
#' @param seed Seed used for reproducibility. Default is 123.
#' @param convergence_tolerance Threshold designated for stopping criterion. If the difference of parameter estimates from one iteration to the next all have a p-value (under a paired t-test) greater than this value, the parameter estimates are declared to have converged. Default is 0.01.
#' @param acceptable_fit_p_value_threshold A p-value threshold for how closely statistics of observed network conform to statistics of networks simulated from GERGM parameterized by converged final parameter estimates. Default value is 0.05.
#' @param force_x_theta_updates Defaults to 1 where theta estimation is not allowed to converge until thetas have updated for x iterations . Useful when model is not degenerate but simulated statistics do not match observed network well when algorithm stops after first x updates.
#' @param output_directory The directory where you would like output generated by the GERGM estimation proceedure to be saved (if output_name is specified). This includes, GOF, trace, and parameter estimate plots, as well as a summary of the estimation proceedure and an .Rdata file containing the GERGM object returned by this function. May be left as NULL if the user would prefer all plots be printed to the graphics device.
#' @param output_name The common name stem you would like to assign to all object output by the gergm function. Default value of NULL will not save any output directly to .pdf files, it will be printed to the console instead. Must be a character string or NULL. For example, if "Test" is supplied as the output_name, then 4 files will be output: "Test_GOF.pdf", "Test_Parameter_Estimates.pdf", "Test_GERGM_Object.Rdata", "Test_Estimation_Log.txt", and "Test_Trace_Plot.pdf"
#' @param generate_plots Defaults to TRUE, if FALSE, then no diagnostic or parameter plots are generated.
#' @param is_correlation_network Defaults to TRUE if this function is used
#' @return A gergm object containing parameter estimates.
#' @export
gergm.corr <- function(formula,
                  use_MPLE_only = c(FALSE, TRUE),
                  maximum_number_of_theta_updates = 100,
                  number_of_networks_to_simulate = 500,
                  thin = 1,
                  proposal_variance = 0.1,
                  downweight_statistics_together = TRUE,
                  MCMC_burnin = 100,
                  seed = 123,
                  convergence_tolerance = 0.01,
                  acceptable_fit_p_value_threshold = 0.05,
                  force_x_theta_updates = 1,
                  output_directory = NULL,
                  output_name = NULL,
                  generate_plots = TRUE
){
  estimation_method <- "Metropolis"
  MPLE.only <- use_MPLE_only
  tolerance <- convergence_tolerance
  shape.parameter <- proposal_variance
  method <- estimation_method
  nsim <- number_of_networks_to_simulate
  #' hard coded possible stats
  possible_structural_terms <- c("out2star", "in2star", "ctriads", "recip", "ttriads", "edges")
  possible_covariate_terms <- c("absdiff", "nodecov", "nodefactor", "sender", "receiver")
  possible_network_terms <- "netcov"
  possible_transformations <- c("cauchy", "logcauchy", "gaussian", "lognormal")
  together <- 0
  if(downweight_statistics_together == TRUE){
    together <- 1
  }
  #' set logical values for whether we are using MPLE only, whether the network
  #' is directed, and which estimation method we are using as well as the
  #' transformation type
  use_MPLE_only <- use_MPLE_only[1] #default is FALSE
  directed <- FALSE #always undirected in the correlation case
  #estimation_method <- estimation_method[1] #default is Gibbs


  #for correlation matrices, we must use M-H
  if(is.null(output_directory) & !is.null(output_name)){
    stop("You have specified an output file name but no output directory. Please specify both or neither.")
  }

  #' convert logical to numeric indicator
  if(downweight_statistics_together){
    downweight_statistics_together <- 1
  } else{
    downweight_statistics_together <- 0
  }

  #make sure proposal variance is greater than zero
  if(proposal_variance <= 0){
    proposal_variance <- 0.0000001
    cat("You supplied a proposal variance that was less than or equal to zero. It has been reset to 0.0000001, considder respecifying...\n")
  }

  formula <- as.formula(formula)


  #--------------------------------------------------
  #1. Create GERGM object from network
  res1 <- Parse_Formula_Object(formula,
                               possible_structural_terms,
                               possible_covariate_terms,
                               possible_network_terms,
                               raw_network = NULL,
                               theta = NULL,
                               terms_to_parse = "structural")

  thetas <- res1$thetas
  network <- res1$net
  alphas <- res1$alphas
  statistics <- res1$statistics

  thetas <- t(as.matrix(thetas))
  thetas <- rbind(thetas, NA)
  colnames(thetas) <- possible_structural_terms
  rownames(thetas) <- c("est", "se")
  thetas <- as.data.frame(thetas)
  lambda.coef <- as.data.frame(0)

  ## Get the bounded network according to the transformation

  bounded.network <- transform.correlations(network)

  GERGM_Object <- Create_GERGM_Object(network = network,
                                      bounded.network = bounded.network,
                                      formula = formula,
                                      thetas = thetas,
                                      lambda = lambda.coef,
                                      alpha = alphas,
                                      together = together,
                                      possible.stats = possible_structural_terms)

  #Set this to be true since it is assumed that the input matrix is a correlation matrix
  GERGM_Object@is_correlation_network = TRUE

  GERGM_Object@stats_to_use <- statistics


  GERGM_Object@theta_estimation_converged <- FALSE
  GERGM_Object@lambda_estimation_converged <- FALSE
  GERGM_Object@observed_network  <- GERGM_Object@network
  GERGM_Object@observed_bounded_network <- GERGM_Object@bounded.network
  GERGM_Object@undirected_network <- TRUE
  GERGM_Object@is_correlation_network <- TRUE


  if(is.null(output_name)){
    GERGM_Object@print_output <- FALSE
  } else{
    GERGM_Object@print_output <- TRUE
  }
  #--------------------------------------------------
  #2. Estimate GERGM with correlation network

  #set the seed
  set.seed(seed)
  possible.stats <- possible_structural_terms
  alphas <- GERGM_Object@weights
  net <- GERGM_Object@network

  rhs.formula <- possible.stats[statistics > 0]
  rhs <- paste(rhs.formula, collapse = " + ")  #rewriting a formula for tnet


  #Begin Estimation
  GERGM_Object@lambda_estimation_converged <- TRUE
  num.theta <- length(which(GERGM_Object@stats_to_use > 0))
  theta <- list()
  theta$par <- rep(0, num.theta)
  num.nodes <- GERGM_Object@num_nodes

  ##I: MPLE estimation
  if(MPLE.only == TRUE){
    ###
    statistics <- GERGM_Object@stats_to_use
    alphas <- GERGM_Object@weights
    cat("Estimating Theta via MPLE... \n")
    GERGM_Object <- store_console_output(GERGM_Object, "Estimating Theta via MPLE... \n")
    theta.init <- mple.corr(GERGM_Object@network, GERGM_Object@bounded.network,
                      statistics = GERGM_Object@stats_to_use,
                      directed = directed)
      #print(theta.init)
      GERGM_Object <- store_console_output(GERGM_Object,paste("\nMPLE Thetas: ", theta.init$par, "\n"))
      theta <- theta.init
      lambda <- as.data.frame(0)
      theta.std.errors <- 1 / sqrt(abs(diag(theta.init$hessian)))
      GERGM_Object@theta.par <- theta.init$par
    }

  ##II: MCMCMLE estimation
    if(MPLE.only != TRUE){
      ret_list <- MCMCMLE.corr(num.draws = nsim,
                          mc.num.iterations = maximum_number_of_theta_updates,
                          thin = thin,
                          MCMC.burnin = MCMC_burnin,
                          theta = theta$par,
                          directed = directed,
                          method = method,
                          shape.parameter = shape.parameter,
                          together = together,
                          tolerance = tolerance,
                          seed2 = seed,
                          possible.stats = possible.stats,
                          GERGM_Object = GERGM_Object,
                          force_x_theta_updates = force_x_theta_updates)

      theta.new <- ret_list[[1]]
      GERGM_Object <- ret_list[[2]]

      theta.std.errors <- 1 / sqrt(abs(diag(theta.new$hessian)))
      theta <- theta.new
      lambda <- as.data.frame(0)
    }

  theta <- t(as.matrix(theta$par))
  theta <- rbind(theta, theta.std.errors)
  colnames(theta) <- rhs.formula
  rownames(theta) <- c("est", "se")
  theta <- as.data.frame(theta)
  GERGM_Object@theta.coef <- theta
  GERGM_Object@lambda.coef <- lambda
  GERGM_Object@is_correlation_network <- TRUE
  #-----------------------------------------------
  #3. Perform degeneracy diagnostics and create GOF plots
  if(!GERGM_Object@theta_estimation_converged){
    warning("Estimation proceedure did not detect convergence in Theta estimates. Estimation halted when maximum number of updates was reached. Be careful to assure good model fit or select a more relaxed convergence criterion.")
    GERGM_Object <- store_console_output(GERGM_Object,"Estimation proceedure did not detect convergence in Theta estimates. Estimation halted when maximum number of updates was reached. Be careful to assure good model fit or select a more relaxed convergence criterion.")
  }
  if(!GERGM_Object@lambda_estimation_converged){
    warning("Estimation proceedure did not detect convergence in Lambda estimates. Estimation halted when maximum number of updates was reached. Be careful to assure good model fit or select a more relaxed convergence criterion.")
    GERGM_Object <- store_console_output(GERGM_Object,"Estimation proceedure did not detect convergence in Lambda estimates. Estimation halted when maximum number of updates was reached. Be careful to assure good model fit or select a more relaxed convergence criterion.")
  }

  #Simulate many networks from the original correlation network
  #Here, we will only use the Metropolis sampler
  GERGM_Object <- Simulate_GERGM(GERGM_Object,
                                 nsim = number_of_networks_to_simulate,
                                 method = "Metropolis",
                                 MCMC.burnin = MCMC_burnin,
                                 thin = thin,
                                 shape.parameter = proposal_variance,
                                 together = downweight_statistics_together,
                                 seed1 = seed,
                                 possible.stats = possible_structural_terms)

  #which(GERGM_Object@stats_to_use == 1)
  #colnames(GERGM_Object@lambda.coef) = gpar.names
  num.nodes <- GERGM_Object@num_nodes
  triples <- t(combn(1:num.nodes, 3))
  pairs <- t(combn(1:num.nodes, 2))
  # initialize the network with the observed network
  init.statistics <- h2(GERGM_Object@bounded.network,
                        triples = triples,
                        statistics = rep(1, length(possible_structural_terms)),
                        alphas = GERGM_Object@weights,
                        together = downweight_statistics_together)

  hsn.tot <- GERGM_Object@MCMC_output$Statistics
  #calculate t.test p-values for calculating the difference in the means of
  # the newly simulated data with the original network
  statistic_test_p_values <- rep(NA,length(possible_structural_terms))
  for(i in 1:length(possible_structural_terms)){
    statistic_test_p_values[i] <- t.test(hsn.tot[, i],
                                         mu = init.statistics[i])$p.value
  }

  stats.data <- data.frame(Observed = init.statistics,
                           Simulated = colMeans(hsn.tot))
  rownames(stats.data) <- possible_structural_terms
  cat("Statistics of observed network and networks simulated from final theta parameter estimates:\n")
  GERGM_Object <- store_console_output(GERGM_Object,"Statistics of observed network and networks simulated from final theta parameter estimates:\n")

  print(stats.data)
  GERGM_Object <- store_console_output(GERGM_Object, toString(stats.data))

  statistic_test_p_values <- data.frame(statistic_test_p_values)
  rownames(statistic_test_p_values) <- possible_structural_terms
  cat("\nt-test p values for statistics of observed network and networks simulated from final theta parameter estimates:\n \n")
  GERGM_Object <- store_console_output(GERGM_Object,"\nt-test p values for statistics of observed network and networks simulated from final theta parameter estimates:\n \n")
  print(statistic_test_p_values)
  GERGM_Object <- store_console_output(GERGM_Object, toString(statistic_test_p_values))


  colnames(statistic_test_p_values) <- "p_values"
  GERGM_Object@observed_simulated_t_test <- statistic_test_p_values

  #test to see if we have an acceptable fit
  acceptable_fit <- statistic_test_p_values[which(GERGM_Object@stats_to_use == 1), 1]

  if(min(acceptable_fit) > acceptable_fit_p_value_threshold){
    GERGM_Object@acceptable_fit <- TRUE
    message("Parameter estimates simulate networks that are statistically indistinguishable from observed network. ")
    GERGM_Object <- store_console_output(GERGM_Object,"Parameter estimates simulate networks that are statistically indistinguishable from observed network. ")
  }else{
    GERGM_Object@acceptable_fit <- FALSE
    message("Parameter estimates simulate networks that are statistically distinguishable from observed network. Consider respecifying.")
    GERGM_Object <- store_console_output(GERGM_Object, "Parameter estimates simulate networks that are statistically distinguishable from observed network. Considder respecifying.")
  }

  # make GOF plot
  # Gof_Plot(GERGM_Object)

  #4. output everything to the appropriate files and return GERGM object.
  if(generate_plots){
    # only generate output if output_name is not NULL
    if(!is.null(output_name)){
      if(is.null(output_directory)){
        output_directory <- getwd()
      }
      current_directory <- getwd()
      setwd(output_directory)

      pdf(file = paste(output_name,"_GOF.pdf",sep = ""), height = 4, width = 8)
      GOF(GERGM_Object)
      dev.off()

      pdf(file = paste(output_name,"_Parameter_Estimates.pdf",sep = ""), height = 4, width = 5)
      Estimate_Plot(GERGM_Object)
      dev.off()

      pdf(file = paste(output_name,"_Trace_Plot.pdf",sep = ""), height = 4, width = 6)
      Trace_Plot(GERGM_Object)
      dev.off()

      save(GERGM_Object, file = paste(output_name,"_GERGM_Object.Rdata",sep = ""))

      write.table(GERGM_Object@console_output,file = paste(output_name,"_Estimation_Log.txt",sep = ""),row.names = F,col.names = F,fileEncoding = "utf8", quote = F)

      setwd(current_directory)
    } else{
      # if we are not saving everything to a directory then just print stuff to
      # the graphics device
      GOF(GERGM_Object)
      Sys.sleep(2)
      Estimate_Plot(GERGM_Object)
      Sys.sleep(2)
      Trace_Plot(GERGM_Object)
    }
  }
  return(GERGM_Object)
}

